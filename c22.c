#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <errno.h>
#include <time.h>

int main() {
	//C语言可以创建变长数组-C99中增加了
	//linux中 gcc编译支持C99标准 
	//gcc test.c-std=c99

	//动态内存管理
	//・为什么存在动态内存分配
	int val = 20;//在栈空间上开辟四个字节
	char arr[10] = { 0 };//在栈空间上开辟10个字节的连续空间I但是上述的开辟空间的方式有两个特点：
		//1.空间开辟大小是固定的。
		//2.数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。
		//但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时候就只能试试动态存开辟了。
	
	//・动态内存函数的介绍
	//	malloc 动态内存开辟的函数：
		void* malloc(size_t size);
	//这个函数向内存申请一块(*连续可用)的空间，并返回指向这块空间的指针。
	//	・如果开辟成功，则返回一个指向开辟好空间的指针。
	//	・如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
	//	・返回值的类型是void*，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
	//	・如果参数size为0，malloc的行为标准是未定义的，取决于编译器。
	int* p=(int*)malloc(10 * sizeof(int));//向内存申请10个整型空间
	if (p == NULL) {
		//打印错误
		printf("%s\n",strerror(errno));
	}
	else
	{
		//正常使用空间
		int i = 0;
		for ( i = 0; i < 10; i++)
		{
			*(p + i) = i;
		}
		for (i = 0; i < 10; i++)
		{
			printf("%d ",*(p+i));

		}
	}	
	//当动态申请的空间不再使用的时候
	//就应该还给操作系统
	//	free 动态内存的释放和回收:
	//	void free(void* ptr);
	//	free函数用来释放动态开辟的内存。
	//		・如果参数ptr指向的空间不是动态开辟的，那free函数的行为是未定义的。
	//		・如果参数ptr是NULL指针，则函数什么事都不做。
	//	malloc和free都声明在stdlib.h头文件中。
	free(p);

	//	calloc 也用来动态内存分配 
	//	void* calloc(size_t num, size_t size);
	//	・函数的功能是为num个大小为size的元素开辟一块空间，并且把空间的每个字节初始化为0。
	//	・与函数malloc的区别只在于calloc会在返回地址之前把申请的空间的每个字节初始化为全0。
	int* p1=(int*)calloc(10, sizeof(int));
	if (p1 == NULL) {
		printf("%s\n", strerror(errno));
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p1 + i));

		}
	}
	free(p1);
	//所以如果我们对申请的内存空间的内容要求初始化，那么可以很方便的使用calloc函数来完成任务。
	//	realloc 动态开辟内存大小的调整
	//	void* realloc(void* ptr, size_t size);
	//	・ptr是要调整的内存地址
	//	・size是调整之后新大小
	//	・返回值为调整之后的内存起始位置。
	//	・这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间。
	//	・realloc在调整内存空间的是存在两种情况
	//		情况1：原有空间之后有足够大的空间
	//		当是情况1的时候，要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发生变化。
	//		情况2：原有空间之后没有足够大的空间
	//		情况2的时候，原有空间之后没有足够多的空间时，扩展的方法是：在堆空间上另找一个合适大小的连续空间来使用。这样函数返回的是一个新的内存地址。
	//		总结：得用一个新的变量来授受realloc函数的返回值
	int* p2 = (int*)malloc(20);
	if (p2 == NULL) {
		printf("%s\n", strerror(errno));
	}
	else
	{
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			*(p2 + i) = i;
		}
	}
	int* p3=realloc(p2, 40);
	if (p3 != NULL) {
		p2 = p3;
		int i = 0;
		for (i = 0; i < 10; i++)
		{
			printf("%d ", *(p2 + i));
		}
	}
	free(p2);
	//・常见的动态内存错误
	//		对NULL指针的解引用操作(开辟动态内存后要判断指针是否为空)
	//		对动态开辟空间的越界访问（不要超过开辟空间的大小）
	//		对非动态开辟内存使用free释放
	//		使用free释放一块动态开辟内存的一部分
	//		对同一块动态内存多次释放
	//		动态开辟内存忘记释放（内存泄漏）

	//C/C++程序的内存开辟
	//区域划分（自上往下）
	//内核空间（用户代码不能读写）
	//栈区（stack）：（向下增长）在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。
	//内存映射段（文件映射、动态库、匿名映射）
	// 堆区（heap）:（向上增长)一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表。
	//数据段（静态区）（static）(全局数据、静态数据),存放全局变量、静态数据。程序结束后由系统释放。
	//代码段（可执行代码/只读常量）存放函数体（类成员函数和全局函数）的二进制代码。
	return 0;
}
