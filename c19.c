#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <stddef.h>

//例如描述一个学生：
struct Stu{
	char name[20];//名字
	int age;//年龄
	char sex[5];//性别
	char id[20];//学号
}s4,s5;//分号不能丢
struct Stu s3;//s3,4,5都是全局变量

//匿名结构体
struct {
	int a;
	char b;
	float c;
}x; 

struct {
	int a;
	char b; 
	float c;
}a[20], *p;
//	结构的自引用 -错误
struct Node {
	int data;
	struct Node next;
};
//	结构的自引用 -正确
struct Node{
	int data;
	struct Node* next;
};

//offsetof(); 
struct  S
{
	char c;
	int i;
	double d;
};

//位段
struct A {
	int _a : 2;
	int _b : 5; 
	int _c : 10; 
	int _d : 30;
};

int main() {
	//内置类型-C语言自己的数据类型 比如int

	//复杂对象-复杂类型
	//自定义类型：结构体、枚举、联合体

	//・结构体
	//结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。
	//	o结构体类型的声明
	//		struct tag {
	//		member - list;
	//		}variable - list;
	//特殊声明-  匿名结构体 -如上
	//	o结构的自引用 -如上
	//	o结构体变量的定义和初始化
	//		创建的结构体变量 
			struct Stu s1; 
			struct Stu s2;
	//	初始化：定义变量的同时赋初值。
	//	o结构体内存对齐
	//	1.第一个成员在与结构体变量偏移量为0的地址处。
	//	2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
	//		对齐数 = 编译器默认的一个对齐数与该成员大小的较小值。
	//		VS中默认的值为8
	//	3.结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
	//	4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数)的整数倍。
	//	为什么存在内存对齐？
	//		1.平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
	//		2.性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。
	//	    总体来说：
	//		结构体的内存对齐是拿空间来换取时间的做法。
	//		那在设计结构体的时候，我们既要满足对齐，又要节省空间，如何做到：
	//		让占用空间小的成员尽量集中在一起。
	//		修改默认对齐数 - #pragma pack(x) 设置默认对齐数为8
	//	offsetof();  需要#include <stddef.h>
			printf("%d\n", offsetof(struct S, c));
			printf("%d\n", offsetof(struct S, i));
			printf("%d\n", offsetof(struct S, d));
	//	o结构体传参
	//		函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销。
	//		如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降。
	//		结论：结构体传参的时候，要传结构体的地址(指针)。
	//	o结构体实现位段（位段的填充&可移植性）
	//		位段的声明和结构是类似的，有两个不同：
	//		1.位段的成员必须是int、unsigned int 或signed int。
	//		2.位段的成员名后边有一个冒号和一个数字。
	//		位段-二进制位
	//		位段的内存分配 - 为了节省空间
	//			1.位段的成员可以是int unsigned int signed int或者是char（属于整形家族）类型
	//			2.位段的空间上是按照需要以4个字节（int）或者1个字节（char)的方式来开辟的。
	//			3.位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段。
	//		位段的跨平台问题
	//			1.int位段被当成有符号数还是无符号数是不确定的。
	//			2.位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题。
	//			3.位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义。
	//			4.当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的。
	//			总结：
	//			跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在。
	return 0;
}